# # 目录


</br>
</br>

# # 类

</br>

## # java 层

</br>

#### FlutterActivity

FlutterActivity是将Flutter集成到Android应用中的最简单最直接的方式，用于显示一个全屏的Flutter UI。主要职责是：

- 显示一个Android的lauch screen；
- 显示Flutter的splash screen；
- 设置状态栏；
- 选择Dart执行应用包路径和入口点；
- 选择Flutter的初始化路由；
- 如果需要的话，渲染透明度；
- 提供子类钩子，提供和配置FlutterEngine。

> 在Engine中存在两个FlutterActivity（shell/platform/android/io/flutter/app/FlutterActivity.java和shell/platform/android/io/flutter/embedding/android/FlutterActivity.java），其中在2020年5月13日的代码提交中，前一个FlutterActivity注释修改为废弃Activity基类。所以现在可用的Activity基类是后一个。

</br>

#### FlutterActivityAndFragmentDelegate

作用

- FlutterActivity和FlutterFragment之间相同的Flutter逻辑的委托

为什么要用这个类

- 假设可以在Activity中放置一个 Fragment，那么在FlutterActivity中使用一个FlutterFragment更有意义。Fragment支持库为应用程序增加了100k二进制大小，而全Flutter应用程序不需要二进制命中。因此，得出的结论是，Flutter必须基于AOSP([Android Open Source Project: Android 开源项目](https://link.juejin.cn?target=https%3A%2F%2Fsource.android.google.cn%2F))Activity 提供FlutterActivity，并为应用程序添加开发人员提供独立的 FlutterFragment
- 大概意思就是FlutterActivity和FlutterFragment是相互独立的，所以需要一个代理委托类去处理它们之间相同的逻辑

</br>

#### FlutterView

`FlutterView`用于在Android设备上显示Flutter UI

</br>

#### FlutterEngine

FlutterEngine是一个独立的Flutter运行环境，是Dart代码运行在Android应用的容器。

</br>

#### FlutterJNI

```
Interface between Flutter embedding's Java code and Flutter engine's C/C++ code.
Flutter's engine is built with C/C++. The Android Flutter embedding is responsible for coordinating Android OS events and app user interactions with the C/C++ engine. Such coordination requires messaging from an Android app in Java code to the C/C++ engine code. This communication requires a JNI (Java Native Interface) API to cross the Java/native boundary.

The entirety of Flutter's JNI API is codified in FlutterJNI. There are multiple reasons that all such calls are centralized in one class. First, JNI calls are inherently static and contain no Java implementation, therefore there is little reason to associate calls with different classes. Second, every JNI call must be registered in C/C++ code and this registration becomes more complicated with every additional Java class that contains JNI calls. Third, most Android developers are not familiar with native development or JNI intricacies, therefore it is in the interest of future maintenance to reduce the API surface that includes JNI declarations. Thus, all Flutter JNI calls are centralized in FlutterJNI.

Despite the fact that individual JNI calls are inherently static, there is state that exists within FlutterJNI. Most calls within FlutterJNI correspond to a specific "platform view", of which there may be many. Therefore, each FlutterJNI instance holds onto a "native platform view ID" after attachToNative(boolean), which is shared with the native C/C++ engine code. That ID is passed to every platform-view-specific native method. ID management is handled within FlutterJNI so that developers don't have to hold onto that ID.
```
java层调用c++层的

</br>

#### DartExecutor

DartExecutor用于配置、启动、执行Dart代码

</br>
</br>

## # c/c++ 层

</br>

#### AndroidShellHolder

```
This is the Android owner of the core engine Shell.

This is the top orchestrator class on the C++ side for the Android embedding. It corresponds to a FlutterEngine on the Java side. This class is in C++ because the Shell is in C++ and an Android orchestrator needs to exist to compose it with other Android specific C++ components such as the PlatformViewAndroid. This composition of many-to-one C++ components would be difficult to do through JNI whereas a FlutterEngine and AndroidShellHolder has a 1:1 relationship.

Technically, the FlutterJNI class owns this AndroidShellHolder class instance, but the FlutterJNI class is meant to be mostly static and has minimal state to perform the C++ pointer <-> Java class instance translation.

Definition at line 40 of file android_shell_holder.h.
```
- 我们知道 embedding 里都是 Java 类（FlutterActivity、FlutterView、FlutterEngine ...）
- 但是engine层和gpu等的交互是c/c++写的
- 所以这里的AndroidShellHolder就是两个沟通的媒介
- 
```
embedding
	⬆️⬇️
AndroidShellHolder
	⬆️⬇️
engine
```

</br>