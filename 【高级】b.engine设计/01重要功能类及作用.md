# # 目录


</br>
</br>

# # 类

</br>

## # java 层

</br>

#### FlutterJNI

```
Interface between Flutter embedding's Java code and Flutter engine's C/C++ code.
Flutter's engine is built with C/C++. The Android Flutter embedding is responsible for coordinating Android OS events and app user interactions with the C/C++ engine. Such coordination requires messaging from an Android app in Java code to the C/C++ engine code. This communication requires a JNI (Java Native Interface) API to cross the Java/native boundary.

The entirety of Flutter's JNI API is codified in FlutterJNI. There are multiple reasons that all such calls are centralized in one class. First, JNI calls are inherently static and contain no Java implementation, therefore there is little reason to associate calls with different classes. Second, every JNI call must be registered in C/C++ code and this registration becomes more complicated with every additional Java class that contains JNI calls. Third, most Android developers are not familiar with native development or JNI intricacies, therefore it is in the interest of future maintenance to reduce the API surface that includes JNI declarations. Thus, all Flutter JNI calls are centralized in FlutterJNI.

Despite the fact that individual JNI calls are inherently static, there is state that exists within FlutterJNI. Most calls within FlutterJNI correspond to a specific "platform view", of which there may be many. Therefore, each FlutterJNI instance holds onto a "native platform view ID" after attachToNative(boolean), which is shared with the native C/C++ engine code. That ID is passed to every platform-view-specific native method. ID management is handled within FlutterJNI so that developers don't have to hold onto that ID.
```
java层调用c++层的

</br>

#### FlutterEngine

FlutterEngine是一个独立的Flutter运行环境，是Dart代码运行在Android应用的容器。

</br>

#### DartExecutor

DartExecutor用于配置、启动、执行Dart代码

</br>
</br>

## # c/c++ 层

</br>

#### AndroidShellHolder

```
This is the Android owner of the core engine Shell.

This is the top orchestrator class on the C++ side for the Android embedding. It corresponds to a FlutterEngine on the Java side. This class is in C++ because the Shell is in C++ and an Android orchestrator needs to exist to compose it with other Android specific C++ components such as the PlatformViewAndroid. This composition of many-to-one C++ components would be difficult to do through JNI whereas a FlutterEngine and AndroidShellHolder has a 1:1 relationship.

Technically, the FlutterJNI class owns this AndroidShellHolder class instance, but the FlutterJNI class is meant to be mostly static and has minimal state to perform the C++ pointer <-> Java class instance translation.

Definition at line 40 of file android_shell_holder.h.
```
- 我们知道 embedding 里都是 Java 类（FlutterActivity、FlutterView、FlutterEngine ...）
- 但是engine层和gpu等的交互是c/c++写的
- 所以这里的AndroidShellHolder就是两个沟通的媒介
- 
```
embedding
	⬆️⬇️
AndroidShellHolder
	⬆️⬇️
engine
```

</br>